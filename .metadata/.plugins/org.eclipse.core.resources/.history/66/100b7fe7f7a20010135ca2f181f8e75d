

/* uart_stream.c
   Gestione ricezione stream via UART in blocchi fissi (16 byte),
   pool buffer + queue + task parser che estrae messaggi [0xAA][LEN][payload].
*/

#include "UsartLib.hpp"
#include "main.h"          // contiene dichiarazioni HAL e huart2
#include "cmsis_os.h"      // FreeRTOS API se CubeMX genera CMSIS, altrimenti usa FreeRTOS.h
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include <string.h>
#include <stdio.h>

#define PACKET_SIZE         16
#define POOL_SIZE           12
#define PARSER_BUF_SIZE     1024
#define HEADER_BYTE         0xAA
#define MAX_MSG_LEN         250

extern UART_HandleTypeDef huart1; // dichiarato in usart.c (CubeMX)

/* temporanei e strutture */
static uint8_t rx_tmp[PACKET_SIZE];
static uint8_t rx_pool[POOL_SIZE][PACKET_SIZE];

static QueueHandle_t qFreeBuffers = NULL;
static QueueHandle_t qReadyBuffers = NULL;

/* per diagnostica */
volatile uint32_t uart_dropped_packets = 0;

/* forward */
static void vAnalyzerTask(void *params);
static void internal_processMessage(uint8_t *msg, uint8_t len);



/* funzione di inizializzazione da chiamare in MX_FREERTOS_Init() */
void UARTStream_Init(void)
{
    /* crea code: POOL_SIZE indici uint32_t */
    qFreeBuffers  = xQueueCreate(POOL_SIZE, sizeof(uint32_t));
    qReadyBuffers = xQueueCreate(POOL_SIZE, sizeof(uint32_t));
    if (qFreeBuffers == NULL || qReadyBuffers == NULL) {
        /* errore: heap insufficiente */
        Error_Handler();
    }

    /* riempio la lista di buffer liberi con indici 0..POOL_SIZE-1 */
    for (uint32_t i = 0; i < POOL_SIZE; ++i) {
        xQueueSend(qFreeBuffers, &i, 0);
    }

    /* creo il task analizzatore (stack es. 512 parole) */
    BaseType_t ok = xTaskCreate(vAnalyzerTask, "Analyzer", 512, NULL, tskIDLE_PRIORITY + 2, NULL);
    if (ok != pdPASS) {
        Error_Handler();
    }

    /* avvio la prima ricezione interrupt: quando arrivano PACKET_SIZE byte verrà chiamata la callback */
    if (HAL_UART_Receive_IT(&huart1, rx_tmp, PACKET_SIZE) != HAL_OK) {
        Error_Handler();
    }
}

/* chiamata da HAL quando arrivano PACKET_SIZE byte (ISR context) */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    if (huart->Instance == USART1)
    {
        uint32_t idx;
        /* prendo un buffer libero (non blocco) */
        if (xQueueReceiveFromISR(qFreeBuffers, &idx, &xHigherPriorityTaskWoken) == pdTRUE)
        {
            /* copio i dati nel buffer del pool */
            memcpy(rx_pool[idx], rx_tmp, PACKET_SIZE);

            /* segnalo che il buffer è pronto */
            xQueueSendFromISR(qReadyBuffers, &idx, &xHigherPriorityTaskWoken);
        }
        else
        {
            /* nessun buffer libero -> scarto il pacchetto */
            uart_dropped_packets++;
        }

        /* riarmo la ricezione per i prossimi PACKET_SIZE byte */
        HAL_UART_Receive_IT(&huart1, rx_tmp, PACKET_SIZE);

        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

/* callback errori: riavvio ricezione */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1) {
        HAL_UART_Receive_IT(&huart1, rx_tmp, PACKET_SIZE);
    }
}

/* task che prende i blocchi, concatena e parser */
static void vAnalyzerTask(void *params)
{
    uint8_t parserBuf[PARSER_BUF_SIZE];
    size_t parserLen = 0;
    uint32_t idx;

    for (;;)
    {
        /* aspetto per sempre un blocco pronto */
        if (xQueueReceive(qReadyBuffers, &idx, portMAX_DELAY) == pdTRUE)
        {
            /* append al buffer di parsing se c'è spazio */
            if (parserLen + PACKET_SIZE <= PARSER_BUF_SIZE) {
                memcpy(parserBuf + parserLen, rx_pool[idx], PACKET_SIZE);
                parserLen += PACKET_SIZE;
            } else {
                /* overflow parser -> reseto tutto */
                parserLen = 0;
            }

            /* restituisco il buffer al pool libero */
            xQueueSend(qFreeBuffers, &idx, 0);

            /* parsing: cerco header e messaggi completi [0xAA][LEN][payload] */
            size_t pos = 0;
            while (parserLen - pos >= 2) { // almeno header+len
                if (parserBuf[pos] != HEADER_BYTE) {
                    pos++;
                    continue;
                }
                uint8_t msg_len = parserBuf[pos + 1];
                if (msg_len < 2 || msg_len > MAX_MSG_LEN) {
                    /* valore di lunghezza invalido -> scarto header */
                    pos++;
                    continue;
                }
                if (parserLen - pos >= msg_len) {
                    /* messaggio completo disponibile */
                    internal_processMessage(&parserBuf[pos], msg_len);
                    pos += msg_len;
                } else {
                    /* messaggio incompleto, attendiamo altri blocchi */
                    break;
                }
            }
            /* shift del rimanente all'inizio */
            if (pos > 0) {
                memmove(parserBuf, parserBuf + pos, parserLen - pos);
                parserLen -= pos;
            }
        }
    }
}

/* qui metti cosa vuoi fare con ogni messaggio estratto (header incluso) */
static void internal_processMessage(uint8_t *msg, uint8_t len)
{
	//DEBUG
    /* Esempio: stampa su UART (attenzione: se usi stessa UART per debug, evita blocchi lunghi) */
    char out[128];
    int off = snprintf(out, sizeof(out), "MSG len=%d: ", len);
    for (int i = 0; i < len && off < (int)sizeof(out) - 4; ++i) {
        off += snprintf(out + off, sizeof(out) - off, "%02X ", msg[i]);
    }
    off += snprintf(out + off, sizeof(out) - off, "\r\n");
    uint8_t buffer[16] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160};

    HAL_UART_Transmit(&huart1, (uint8_t*)out, off, HAL_MAX_DELAY);


    //CODE

}

/* Fornisco una funzione weak che l'utente può sovrascrivere */
void UARTStream_ProcessMessage(uint8_t *msg, uint8_t len)
{
    /* wrapper: chiama la implementazione interna */
    internal_processMessage(msg, len);
}
